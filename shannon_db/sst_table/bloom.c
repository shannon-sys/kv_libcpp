#include "filter_policy.h"

// The FALLTHROUGH_INTENDED macro can be used to annotate implicit fall-through
// between switch labels. The real definition should be provided externally.
// This one is a fallback version for unsupported compilers
#ifndef FALLTHROUGH_INTENDED
#define FALLTHROUGH_INTENDED do { } while (0)
#endif

uint32_t hash(char *data, size_t n, uint32_t seed)
{
	// Similar to murmur hash
	const uint32_t m = 0xc6a4a793;
	const uint32_t r = 24;
	const char* limit = data + n;
	uint32_t h = seed ^ (n * m);

	// Pick up four bytes at a time
	while (data + 4 <= limit) {
		uint32_t w = decode_fixed32(data);
		data += 4;
		h += w;
		h *= m;
		h ^= (h >> 16);
	}

	// Pick up remaining bytes
	switch (limit - data) {
	case 3:
		h += (unsigned char)(data[2]) << 16;
		FALLTHROUGH_INTENDED;
	case 2:
		h += (unsigned char)(data[1]) << 8;
		FALLTHROUGH_INTENDED;
	case 1:
		h += (unsigned char)(data[0]);
		h *= m;
		h ^= (h >> r);
		break;
	}
	return h;
}

static uint32_t bloom_hash(slice_t *key)
{
	return hash(key->data, key->size, 0xbc9f1d34);
}

static const char *bloom_filter_name()
{
	return "leveldb.BuildBloomFilter2";
}

// one dst just save one filter, diffrent from leveldb
static int bloom_create_filter(filter_policy_t *policy,
		slice_t *keys, int n, slice_t *dst)
{
	size_t bits = n * policy->bits_per_key;
	size_t bytes, j;
	int i;
	char *buf = NULL;
	uint32_t h, delta, bitpos;

	if (bits < 64) bits = 64;
	bytes = (bits + 7) / 8;
	bits = bytes * 8;

	buf = (char *)malloc(bytes + 1);
	if (buf == NULL) {
		DEBUG("malloc bloom filter bitmap fail\n");
		return KCORRUPTION;
	}
	memset(buf, 0, bytes + 1);
	buf[bytes] = policy->k; // remember # of probes in filter

	for (i = 0; i < n; ++i) {
		// use double-hashing to generate a sequence of hash values.
		h = bloom_hash(&keys[i]);
		delta = (h >> 17) | (h << 15); // rotate right 17 bits
		for (j = 0; j < policy->k; ++j) {
			bitpos = h % bits;
			buf[bitpos/8] |= (1 << (bitpos % 8));
			h += delta;
		}
	}
	set_slice(dst, buf, bytes + 1);
	return KOK;
}

// return 1: key match, return 0: key do not match
static uint8_t bloom_key_may_match(filter_policy_t *policy,
		slice_t *key, slice_t *bloom_filter)
{
	char *array = bloom_filter->data;
	size_t len = bloom_filter->size;
	size_t bits = (len - 1) * 8;
	size_t k, j;
	uint32_t h, delta, bitpos;

	if (len < 2) return 0;

	// use the encoded k so that we can read filters generated by
	// bloom filters created using different parameters.
	k = array[len-1];
	if (k > 30) {
		// reserved for potentially new encodings for short bloom filters.
		// consider it a match
		return 1;
	}

	h = bloom_hash(key);
	delta = (h >> 17) | (h << 15); // rotate right 17 bits
	for (j = 0; j < k; j++) {
		bitpos = h % bits;
		if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0)
			return 0;
		h += delta;
	}
	return 1;
}

// a good value for bits_per_key is 10, which yields a filter
// with ~ 1% false positive rate.
void bloom_filter_init(filter_policy_t *policy, size_t bits_per_key)
{
	size_t k;

	policy->bits_per_key = bits_per_key;
	k = bits_per_key * 69 / 100; // 0.69 =~ ln(2)
	if (k < 1) k = 1;
	if (k > 30) k = 30;
	policy->k = k;

	policy->create_filter = bloom_create_filter;
	policy->key_may_match = bloom_key_may_match;
	policy->name = bloom_filter_name;
}
